[1mdiff --git a/src/imagePub/ImagePublisher.cpp b/src/imagePub/ImagePublisher.cpp[m
[1mindex 9baddd4..bd91b2e 100644[m
[1m--- a/src/imagePub/ImagePublisher.cpp[m
[1m+++ b/src/imagePub/ImagePublisher.cpp[m
[36m@@ -21,6 +21,7 @@[m
 [m
 #include <thread>[m
 #include <list>[m
[32m+[m[32m#include <iterator>[m
 [m
 #include <iostream>[m
 #include <winrt/Windows.Foundation.Collections.h>[m
[36m@@ -101,6 +102,7 @@[m [mbool ImagePublisher::init(CfgPtr cfg, bool use_env)[m
     unsigned short port = 5100;[m
 [m
    // std::cout << "Using TCP as transport" << std::endl;[m
[32m+[m[32m    // Create a descriptor for the new transport.[m
     auto tcp_transport = std::make_shared<eprosima::fastdds::rtps::TCPv4TransportDescriptor>();[m
     tcp_transport->add_listener_port(5100);[m
     tcp_transport->set_WAN_address("127.0.0.1");[m
[36m@@ -109,25 +111,33 @@[m [mbool ImagePublisher::init(CfgPtr cfg, bool use_env)[m
     // Link the Transport Layer to the Participant.[m
     participant_qos.transport().user_transports.push_back(tcp_transport);[m
 [m
[32m+[m[32m    // Avoid using the default transport[m
[32m+[m[32m    participant_qos.transport().use_builtin_transports = false;[m
[32m+[m
[32m+[m[32m    eprosima::fastrtps::rtps::Locator_t locator;[m
[32m+[m[32m    eprosima::fastrtps::rtps::IPLocator::setIPv4(locator, "127.0.0.1");[m
[32m+[m[32m    eprosima::fastrtps::rtps::IPLocator::setWan(locator, "127.0.0.1");[m
[32m+[m[32m    eprosima::fastrtps::rtps::IPLocator::setPhysicalPort(locator, 5100);[m
[32m+[m[32m    eprosima::fastrtps::rtps::IPLocator::setLogicalPort(locator, 5100);[m
[32m+[m
[32m+[m[32m    participant_qos.wire_protocol().builtin.metatrafficUnicastLocatorList.push_back(locator);[m
[32m+[m[32m    participant_qos.wire_protocol().default_unicast_locator_list.push_back(locator);[m
[32m+[m
     //CREATE THE PARTICIPANT[m
[31m-  /*[m
[31m-    pqos.wire_protocol().builtin.discovery_config.leaseDuration = eprosima::fastrtps::c_TimeInfinite;[m
[31m-    pqos.wire_protocol().builtin.discovery_config.leaseDuration_announcementperiod = eprosima::fastrtps::Duration_t(5, 0);[m
[31m-   [m
[31m-    pqos.transport().use_builtin_transports = false;[m
 [m
[32m+[m[32m    participant_qos.wire_protocol().builtin.discovery_config.leaseDuration = eprosima::fastrtps::c_TimeInfinite;[m
[32m+[m[32m    participant_qos.wire_protocol().builtin.discovery_config.leaseDuration_announcementperiod = eprosima::fastrtps::Duration_t(5, 0);[m
[32m+[m[41m   [m
[32m+[m[32m    /*[m
     std::shared_ptr<TCPv4TransportDescriptor> descriptor = std::make_shared<TCPv4TransportDescriptor>();[m
 [m
[31m-  [m
     descriptor->interfaceWhiteList.push_back(wan_ip);[m
     std::cout << "Whitelisted " << wan_ip << std::endl;[m
    [m
[31m-[m
     descriptor->sendBufferSize = 0;[m
     descriptor->receiveBufferSize = 0;[m
     */[m
 [m
[31m-[m
     // Limit to 300kb per second.[m
     static const char* flow_controller_name = FASTDDS_FLOW_CONTROLLER_DEFAULT;[m
     //"example_flow_controller";[m
[36m@@ -268,34 +278,40 @@[m [mvoid ImagePublisher::PubListener::on_publication_matched([m
     const int numSamples = cfgCam_.numSamples_;[m
     uint64_t tBeg = APP_TIME_CURRENT_NS;[m
     uint64_t tEnd = APP_TIME_CURRENT_NS;[m
[31m-[m
[32m+[m[32m    uint64_t dealayNanosecond = 1e9 / frequency_;[m
     std::cout << "sending " << numSamples << " samples at " << frequency_ << std::endl;[m
     for (uint32_t i = 0; i < numSamples; i++) {[m
[31m-   [m
[32m+[m
         acqImgMsg();[m
         preparImgMsg(i);[m
 [m
[31m-       // image_list.push_back(image_);[m
[31m-  [m
[32m+[m[32m        image_list.push_back(image_);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m   // std::list<Image>::iterator it;[m
[32m+[m[32m    //for (it = image_list.begin(); it != image_list.end(); ++it)[m
[32m+[m[32m    for (Image oneImage : image_list)[m
[32m+[m[32m    {[m
         tEnd = APP_TIME_CURRENT_NS;[m
 [m
[31m-        uint64_t dealayNanosecond = 1e9 / frequency_;[m
[32m+[m[41m       [m
         //std::cout << "**dealayNanosecond " << dealayNanosecond  << std::endl;[m
         // [m
         //wait utill delay time, interval[m
[31m-    [m
[32m+[m
         while (tEnd - tBeg <= dealayNanosecond) {[m
             tEnd = APP_TIME_CURRENT_NS;[m
[31m-           //uncomment this line to test if a delay is needed[m
[31m-            std::cout << "**in while loop " << std::endl;[m
[32m+[m[32m            //uncomment this line to test if a delay is needed[m
[32m+[m[32m           // std::cout << "**in while loop " << std::endl;[m
         }[m
[31m-       [m
[31m-  [m
[31m-        if (!publish(false, numSamples)) {[m
[31m-            std::cout << "unable to send sample #" << i << std::endl;[m
[32m+[m
[32m+[m[32m        // std::cout << "**oneImage.frame_number " << oneImage.frame_number() << std::endl;[m
[32m+[m
[32m+[m[32m        if (!publish(false, numSamples, oneImage)) {[m
[32m+[m[32m            std::cout << "unable to send sample #" << std::endl;[m
         }[m
         tBeg = APP_TIME_CURRENT_NS;[m
[31m-       }[m
[32m+[m[32m    }[m
            [m
          [m
     [m
[36m@@ -363,15 +379,16 @@[m [mvoid ImagePublisher::preparImgMsg( const uint32_t frameNum )[m
   image_.height(frame_.rows);[m
 }[m
 [m
[31m-bool ImagePublisher::publish(bool waitForListener, uint32_t frequency)[m
[31m-//bool ImagePublisher::publish(bool waitForListener, uint32_t frequency, Image oneImage)[m
[32m+[m[32m//bool ImagePublisher::publish(bool waitForListener, uint32_t frequency)[m
[32m+[m[32mbool ImagePublisher::publish(bool waitForListener, uint32_t frequency, Image oneImage)[m
 {[m
[31m-   // std::cout << "in publish frequency " << frequency << std::endl;[m
[32m+[m[32m   // std::cout << "**oneImage.frame_number " << oneImage.frame_number() << std::endl;[m
[32m+[m[32m  //  std::cout << "in publish frequency " << frequency << std::endl;[m
     if (listener_.firstConnected_ || !waitForListener || listener_.matched_ > 0)[m
     {[m
[31m-      //  std::cout << "in publish frequency " << frequency << std::endl;[m
[31m-        image_.publisher_send_time(APP_TIME_CURRENT_NS);[m
[31m-        writer_->write(&image_);[m
[32m+[m[32m       // std::cout << "in publish frequency 2 222" << frequency << std::endl;[m
[32m+[m[32m        oneImage.publisher_send_time(APP_TIME_CURRENT_NS);[m
[32m+[m[32m        writer_->write(&oneImage);[m
         return true;[m
     }[m
     return false;[m
